{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#referencias","title":"Refer\u00eancias","text":"<ul> <li>http://www.riscbook.com/portuguese/</li> <li>https://riscv-programming.org/</li> <li>https://www.riscvschool.com/</li> </ul>"},{"location":"labs/","title":"Parte pr\u00e1tica","text":""},{"location":"labs/#simulacoes","title":"Simula\u00e7\u00f5es","text":"<p>Em geral, as simula\u00e7\u00f5es funcionais podem todas ser realizada em ambiente Linux. A seguir est\u00e1 o comando de instala\u00e7\u00e3o, dependendo de sua distribui\u00e7\u00e3o, dos pacotes necess\u00e1rios: <code>[apt|snap|yum|rpm|dnf|pacman] install iverilog gtkwave gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu qemu-user qemu-user-static</code></p>"},{"location":"labs/#extensoes-uteis-para-o-vscode","title":"Extens\u00f5es \u00fateis para o VSCode","text":"<ul> <li>Verilog</li> <li>WaveTrave</li> <li>DigitalJS</li> <li>RISCV</li> </ul>"},{"location":"labs/#kit-de-fpga","title":"Kit de FPGA","text":"<p>Para sintetizar cada laborat\u00f3rio e fazer o download para a placa, digite <code>..\\make_wannabe.bat</code> (Windows) ou <code>make -f ../Makefile</code> (Linux) dentro do diret\u00f3rio do respectivo laborat\u00f3rio (n\u00e3o nesta pasta, pois os comandos fazem refer\u00eancia ao n\u00edvel superior). </p>"},{"location":"labs/#de0-cv","title":"DE0-CV","text":"<p>Consulte o manual do kit para compreender como usar cada recurso. Um arquivo de pinos \u00e9 usado para mapear as entradas e sa\u00eddas.</p>"},{"location":"labs/01-banner/","title":"Criando um banner no kit de FPGAs","text":"<p>Se voc\u00ea n\u00e3o se lembra de como usar o kit de FPGAs e as ferramentas, d\u00ea uma olhada neste laborat\u00f3rio.</p> <p>O objetivo desta pr\u00e1tica \u00e9 usar uma mem\u00f3ria ROM para criar um efeito visual que simule um banner nos LEDs do kit. O conte\u00fado da mem\u00f3ria \u00e9 exibido nos LEDs uma linha por vez, o que visto rapidamente, em movimento ou filmado pode revelar seu conte\u00fado completo se usada a frequ\u00eancia correta. </p> <p>Os arquivos est\u00e3o todos completos, voc\u00ea s\u00f3 precisa modificar o conte\u00fado da mem\u00f3ria para exibir o que desejar e variar a frequ\u00eacia at\u00e9 encontrar uma que seja poss\u00edvel ver o banner. </p> <p></p>"},{"location":"labs/02-decode-game/","title":"Decodificando instru\u00e7\u00f5es do RISC-V","text":"<p>O objetivo desta pr\u00e1tica \u00e9 construir um jogo para compreender a codifica\u00e7\u00e3o de instru\u00e7\u00f5es e c\u00e1lculos de endere\u00e7o no RISC-V. Ele pode ser feito em qualquer linguagem de sua prefer\u00eancia, usando ou n\u00e3o o kit de FPGAs. A partir de um programa fornecido ou gerado aleat\u00f3riamente, o jogador precisa adivinhar partes das instru\u00e7\u00f5es ou endere\u00e7os para ganhar pontos ou avan\u00e7ar no jogo. A seguir est\u00e1 um fluxo poss\u00edvel: </p> <pre><code>flowchart TD\n    Start([\"Escolha Instru\u00e7\u00e3o\"])\n    Opcode[\"Adivinhar OPCODE (7 bits)\"]\n    Format{\"Formato?\"}\n    NextInstr([\"Pr\u00f3xima Instru\u00e7\u00e3o\"])\n\n    Start --&gt; Opcode\n    Opcode --&gt; Format\n\n    %% R-Type\n    Format --&gt; RType([\"R-Type\"])\n    RType --&gt; R_rd[\"Adivinhar rd (5)\"]\n    R_rd --&gt; R_funct3[\"Adivinhar funct3 (3)\"]\n    R_funct3 --&gt; R_rs1[\"Adivinhar rs1 (5)\"]\n    R_rs1 --&gt; R_rs2[\"Adivinhar rs2 (5)\"]\n    R_rs2 --&gt; R_funct7[\"Adivinhar funct7 (7)\"]\n    R_funct7 --&gt; NextInstr\n\n    %% I-Type\n    Format --&gt; IType([\"I-Type\"])\n    IType --&gt; I_rd[\"Adivinhar rd (5)\"]\n    I_rd --&gt; I_funct3[\"Adivinhar funct3 (3)\"]\n    I_funct3 --&gt; I_rs1[\"Adivinhar rs1 (5)\"]\n    I_rs1 --&gt; I_imm[\"Adivinhar imm (12)\"]\n    I_imm --&gt; NextInstr\n\n    %% S-Type\n    Format --&gt; SType([\"S-Type\"])\n    SType --&gt; S_funct3[\"Adivinhar funct3 (3)\"]\n    S_funct3 --&gt; S_rs1[\"Adivinhar rs1 (5)\"]\n    S_rs1 --&gt; S_rs2[\"Adivinhar rs2 (5)\"]\n    S_rs2 --&gt; S_imm[\"Adivinhar imm (12, encoded)\"]\n    S_imm --&gt; NextInstr\n\n    %% B-Type\n    Format --&gt; BType([\"B-Type\"])\n    BType --&gt; B_funct3[\"Adivinhar funct3 (3)\"]\n    B_funct3 --&gt; B_rs1[\"Adivinhar rs1 (5)\"]\n    B_rs1 --&gt; B_rs2[\"Adivinhar rs2 (5)\"]\n    B_rs2 --&gt; B_imm[\"Adivinhar imm (13, encoded)\"]\n    B_imm --&gt; NextInstr\n\n    %% U-Type\n    Format --&gt; UType([\"U-Type\"])\n    UType --&gt; U_rd[\"Adivinhar rd (5)\"]\n    U_rd --&gt; U_imm[\"Adivinhar imm (20)\"]\n    U_imm --&gt; NextInstr\n\n    %% J-Type\n    Format --&gt; JType([\"J-Type\"])\n    JType --&gt; J_rd[\"Adivinhar rd (5)\"]\n    J_rd --&gt; J_imm[\"Adivinhar imm (21, encoded)\"]\n    J_imm --&gt; NextInstr\n\n    %% STYLE DEFINITIONS\nclassDef Adivinhar fill:#cce5ff,stroke:#004085,stroke-width:2px;\n    class Opcode,R_rd,R_funct3,R_rs1,R_rs2,R_funct7,I_rd,I_funct3,I_rs1,I_imm,S_funct3,S_rs1,S_rs2,S_imm,B_funct3,B_rs1,B_rs2,B_imm,U_rd,U_imm,J_rd,J_imm Adivinhar;\n</code></pre> <p>Todas as jogadas devem ser informadas em bin\u00e1rio na console!</p> <p>Procure usar programas com instru\u00e7\u00f5es bem diversas, por exemplo:</p> <pre><code>_start:\n    # R-type: registradores\n    add     x5, x1, x2         # R: rd=x5, rs1=x1, rs2=x2, funct3=000, funct7=0000000\n    xor     x4, x2, x3         # R: rd=x4, rs1=x2, rs2=x3, funct3=100, funct7=0000000\n    # I-type (aritm\u00e9tico imediato)\n    addi    x6, x5, 42         # I: rd=x6, rs1=x5, imm=42, funct3=000\n    slli    x5, x6, 3          # I: rd=x5, rs1=x6, shamt=3, funct3=001\n    # I-type (load)\n    lw      x7, 64(x6)          # I: rd=x7, rs1=x6, imm=64, funct3=010\n    lbu     x5, 32(x4)          # I: rd=x5, rs1=x4, imm=32, funct3=100\n    # S-type: store\n    sw      x7, 16(x5)         # S: rs1=x5, rs2=x7, imm=16, funct3=010\n    sb      x6, 16(x2)         # S: rs1=x2, rs2=x6, imm=16, funct3=001\n    # B-type: branch condicional\n    beq     x5, x6, label      # B: rs1=x5, rs2=x6, imm=offset(label), funct3=000\n    bne     x3, x4, label      # B: rs1=x3, rs2=x4, imm=offset(label), funct3=001\n    # U-type: imediato alto\n    lui     x8, 0xABCDE        # U: rd=x8, imm[31:12]=0xABCDE\n    # J-type: salto\n    jal     x1, end            # J: rd=x1 (ra), imm=offset(end)\nlabel:\n    addi    x9, x0, 7          # I: instru\u00e7\u00e3o ap\u00f3s branch\nend:\n    nop                        # I-type: addi x0,x0,0\n</code></pre> <p>Para garantir que as codifica\u00e7\u00f5es est\u00e3o corretas, seu programa deve invocar o GCC para ger\u00e1-la automaticamente. </p> <p>Depois voc\u00ea pode extrair os campos e gerar tabelas como a seguinte:</p> Instr. Opcode rd funct3 rs1 rs2 funct7 imm (decimal/hex) xor x5,x1,x2 0110011 5 100 1 2 0000000 - slli x6,x5,3 0010011 6 001 5 - 0000000 shamt=3 lbu x7,8(x6) 0000011 7 100 6 - - 8 sb x7,16(x5) 0100011 - 001 5 7 - 16 bne x5,x6,label 1100011 - 001 5 6 - offset(label)=calculado lui x8,0xABCDE 0110111 8 - - - - 0xABCDE jal x1,end 1101111 1 - - - - offset(end)=calculado addi x9,x0,7 0010011 9 000 0 - - 7 nop 0010011 0 000 0 - - 0 <p>O jogo deve executar em sistemas Linux apenas no modo console. Incluir coment\u00e1rios no c\u00f3digo fonte e depend\u00eancias necess\u00e1rias para sua execu\u00e7\u00e3o. </p> <p>Um programa de refer\u00eancia foi fornecido, observe os arquivos que ele manipula para entender cada passo. Para test\u00e1-lo, basta digitar <code>make</code> no terminal. </p>"},{"location":"labs/02-decode-game/#referencias","title":"Refer\u00eancias:","text":"<ul> <li>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA, pg. 608</li> <li>From Blinker to RISC-V</li> </ul>"},{"location":"labs/04-riscv-alu/","title":"Escrevendo a ULA do RISC-V","text":"<p>O objetivo desta pr\u00e1tica \u00e9 escrever uma ULA e seu respectivo test bench para o processador RISC-V baseada neste modelo. Utilize o processador de refer\u00eancia e tamb\u00e9m suas refer\u00eancias como modelo. Insira a fun\u00e7\u00e3o <code>$monitor</code> em seus c\u00f3digos, para obter valores reais de suas entradas/sa\u00eddas como as seguintes:</p> <pre><code>PC=00000114 instr=fff28293 funct3=000 aluIn1=00000d93 aluIn2=ffffffff aluOut=00000d92\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d93 aluIn2=00000000 aluOut=00000d93\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d92 aluIn2=00000000 aluOut=00000d92\nPC=00000110 instr=fe029ee3 funct3=001 aluIn1=00000d92 aluIn2=00000000 aluOut=00000d92\nPC=00000110 instr=fff28293 funct3=000 aluIn1=00000d92 aluIn2=ffffffff aluOut=00000d91\nPC=00000114 instr=fff28293 funct3=000 aluIn1=00000d92 aluIn2=ffffffff aluOut=00000d91\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d92 aluIn2=00000000 aluOut=00000d92\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d91 aluIn2=00000000 aluOut=00000d91\nPC=00000110 instr=fe029ee3 funct3=001 aluIn1=00000d91 aluIn2=00000000 aluOut=00000d91\nPC=00000110 instr=fff28293 funct3=000 aluIn1=00000d91 aluIn2=ffffffff aluOut=00000d90\nPC=00000114 instr=fff28293 funct3=000 aluIn1=00000d91 aluIn2=ffffffff aluOut=00000d90\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d91 aluIn2=00000000 aluOut=00000d91\n</code></pre>"},{"location":"labs/04-riscv-alu/#entrega","title":"Entrega","text":"<p>Fa\u00e7a commit do seu c\u00f3digo no reposit\u00f3rio do grupo contendo um script <code>run.sh</code> na raiz que gere um sa\u00edda com todas as opera\u00e7\u00f5es v\u00e1lidas da ULA. Inclua no espa\u00e7o abaixo a sa\u00edda gerada e comente os resultados. Como voc\u00ea n\u00e3o tem o processador completo ainda, sugiro usar os dados das simula\u00e7\u00f5es de outros processadores para gerar um arquivo de testes (e.g. <code>values.tv</code>).</p>"},{"location":"labs/04-riscv-alu/#referencias","title":"Refer\u00eancias","text":"<ul> <li>LigthRISCV </li> </ul>"},{"location":"labs/06-riscv-mono-leds/","title":"Testando seu RISC-V monociclo na placa","text":"<p>O objetivo desta pr\u00e1tica \u00e9 testar diretamente no kit de FPGA o processador que voc\u00ea desenvolveu na simula\u00e7\u00e3o desta semana. Para isso, foi implementado externamente (no SoC<sup>1</sup>) um esquema de E/S mapeados em mem\u00f3ria. Para possibilitar o monociclo, separamos as mem\u00f3rias de instru\u00e7\u00f5es e de dados:</p> <pre><code>  // microprocessor\n  riscvmono cpu(clk, reset, pc, instr, addr, writedata, memwrite, readdata);\n\n  // instructions memory \n  rom instr_mem(pc, instr);\n\n  // data memory \n  ram data_mem(clk, memwrite &amp; isRAM, addr, writedata, readdata);\n</code></pre> <p>A mem\u00f3ria de instru\u00e7\u00f5es \u00e9 uma ROM que recebe o PC e retornar a instru\u00e7\u00e3o correspondente ao endere\u00e7o. J\u00e1 a de dados \u00e9 uma RAM que armazena os dados do programa, que podem ser lidos (<code>lw</code>) ou escritos (<code>sw</code>). Cada uma delas possui apenas 256 posi\u00e7\u00f5es, ou seja, podem ser endere\u00e7adas a partir de um \u00fanico byte. </p> <p>O esquema de E/S mapeado em mem\u00f3ria \u00e9 apresentado a seguir:</p> <pre><code>  // memory-mapped i/o\n  wire isIO  = addr[8]; // 0x0000_0100\n  wire isRAM = !isIO;\n  localparam IO_LEDS_bit = 2; // 0x0000_0104\n  localparam IO_HEX_bit  = 3; // 0x0000_0108\n  reg [23:0] hex_digits; // memory-mapped I/O register for HEX\n  dec9segs hex0(hex_digits[ 3: 0], HEX0);\n  dec9segs hex1(hex_digits[ 7: 4], HEX1);\n  dec9segs hex2(hex_digits[11: 8], HEX2);\n  dec9segs hex3(hex_digits[15:12], HEX3);\n  dec9segs hex4(hex_digits[19:16], HEX4);\n  dec9segs hex5(hex_digits[23:20], HEX5);\n  always @(posedge clk)\n    if (memwrite &amp; isIO) begin // I/O write \n      if (addr[IO_LEDS_bit])\n        LEDR &lt;= writedata;\n      if (addr[IO_HEX_bit])\n        hex_digits &lt;= writedata;\n  end\n</code></pre> <ol> <li> <p>SoC significa System on Chip. No contexto deste projeto ele se refere ao arquivo top level para s\u00edntese, que cont\u00e9m a CPU, mem\u00f3rias de instru\u00e7\u00f5es e de dados, al\u00e9m dos perif\u00e9ricos, neste caso os LEDs e displays de sete segmentos.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/08-riscv-multi-buttons/","title":"Testando seu RISC-V multiciclo na placa","text":"<p>O objetivo desta pr\u00e1tica \u00e9 testar diretamente no kit de FPGA o processador que voc\u00ea desenvolveu na simula\u00e7\u00e3o desta semana. Aproveite o <code>Makefile</code> fornecido l\u00e1 para gerar automaticamente o conte\u00fado da mem\u00f3ria a partir do c\u00f3digo assembly. No processador multiciclo, podemos usar a mesma mem\u00f3ria para instru\u00e7\u00f5es e dados:</p> <pre><code>  // microprocessor\n  riscvmulti cpu(clk, reset, addr, writedata, memwrite, readdata);\n\n  // memory \n  mem ram(clk, memwrite, addr, writedata, MEM_readdata);\n</code></pre> <p>O esquema de E/S mapeado em mem\u00f3ria, fornecido anteriormente, deve ser alterado da seguinte forma para suportar a leitura dos bot\u00f5es da placa:</p> <pre><code>  // memory-mapped i/o\n  wire isIO  = addr[8]; // 0x0000_0100\n  wire isRAM = !isIO;\n  localparam IO_LEDS_bit = 2; // 0x0000_0104\n  localparam IO_HEX_bit  = 3; // 0x0000_0108\n  localparam IO_KEY_bit  = 4; // 0x0000_0110 \n  localparam IO_SW_bit   = 5; // 0x0000_0120\n  reg [23:0] hex_digits; // memory-mapped I/O register for HEX\n  dec9segs hex0(hex_digits[ 3: 0], HEX0);\n  dec9segs hex1(hex_digits[ 7: 4], HEX1);\n  dec9segs hex2(hex_digits[11: 8], HEX2);\n  dec9segs hex3(hex_digits[15:12], HEX3);\n  dec9segs hex4(hex_digits[19:16], HEX4);\n  dec9segs hex5(hex_digits[23:20], HEX5);\n  always @(posedge clk)\n    if (memwrite &amp; isIO) begin // I/O write \n      if (addr[IO_LEDS_bit])\n        LEDR &lt;= writedata;\n      if (addr[IO_HEX_bit])\n        hex_digits &lt;= writedata;\n  end\n  assign IO_readdata = addr[IO_KEY_bit] ? {32'b0, KEY} :\n                       addr[ IO_SW_bit] ? {32'b0,  SW} : \n                                           32'b0       ;\n  assign readdata = isIO ? IO_readdata : MEM_readdata; \n</code></pre> <p>Aproveite o test bench do laborat\u00f3rio anterior para testar o seu software/hardware antes de programar na placa.</p>"}]}